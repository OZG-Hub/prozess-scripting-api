// Generated by delombok
package de.seitenbau.serviceportal.scripting.api.v1.form;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import de.seitenbau.serviceportal.scripting.api.v1.form.button.CustomButtonV1;
import de.seitenbau.serviceportal.scripting.api.v1.form.button.CustomButtonsV1;
import de.seitenbau.serviceportal.scripting.api.v1.form.content.FormContentV1;
import de.seitenbau.serviceportal.scripting.api.v1.form.content.FormFieldContentV1;
import de.seitenbau.serviceportal.scripting.api.v1.form.content.FormReplacementValuesV1;
import lombok.NonNull;

/**
 * Formular.
 */
public class FormV1 {
  /**
   * ID des Formulars.
   */
  @NonNull
  private String id;
  /**
   * Titel dieses Formulars.
   */
  private String title;
  /**
   * Sprache dieses Formulars.
   */
  private String language;
  /**
   * Liste der Formularabschnitte. Default ist eine leere Liste.
   */
  @NonNull
  private List<FormSectionV1> sections;
  /**
   * Quelle, aus der die Inhalte des gesamten Formulars gelesen werden.
   */
  private DataResourcePointerV1 source;
  /**
   * Ziel, in das der Inhalt des gesamten Formulars geschrieben werden.
   */
  private DataResourcePointerV1 target;
  /**
   * Validierungsmeldungen des gesamten Formulars. Default ist leere Menge.
   */
  @NonNull
  private Set<ValidationMessageV1> validationMessages;
  /**
   * Kontext, in dem das Formular abgeschickt wurde.
   */
  private Map<String, Object> context;
  /**
   * Enthält die Custom-Buttons.
   */
  private CustomButtonsV1 customButtons;
  /**
   * Die Ersetzungswerte für Platzhalter in der Formulardefinition, die verwendet wurden, um die
   * Formulardefinition zu vervollständigen. Dient dazu, um aus der Formulardefinition mit Platzhaltern wieder
   * eine vollständige Formulardefinition machen zu können.
   */
  private FormReplacementValuesV1 appliedReplacements;

  /**
   * Erzeugt ein neues Formular mit der gegebenen ID.
   *
   * @param id ID des Formulars, nicht {@code null}
   *
   * @throws NullPointerException Falls die gegebene ID {@code null} ist
   */
  public FormV1(@NonNull String id) {
    if (id == null) {
      throw new NullPointerException("id is marked non-null but is null");
    }
    this.id = id;
    sections = new ArrayList<>();
    validationMessages = new HashSet<>();
  }

  /**
   * Gibt die originale Feldgruppe (nicht Instanz) innerhalb dieses Formulars mit der gegebenen ID zurück.
   *
   * @param id ID einer Feldgruppe, nicht {@code null}
   *
   * @return Feldgruppe mit der gegebenen ID oder {@code null} wenn keine Feldgruppe gefunden wurde
   * @throws NullPointerException Falls die gegebene ID {@code null} ist
   */
  public FieldGroupV1 getGroupTemplate(String id) {
    return sections.stream().flatMap(section -> section.getFieldGroups().stream()).filter(group -> id.equals(group.getId())).findFirst().orElse(null);
  }

  /**
   * Gibt die Feldgruppen-Instanz innerhalb dieses Formulars für die Gruppe mit der gegebenen ID mit dem
   * gegebenen Index zurück.
   *
   * @param id ID einer Feldgruppe, nicht {@code null}
   * @param index Index einer Feldgruppeninstanz
   *
   * @return Feldgruppen-Instanz mit der gegebenen ID und Index,
   * oder {@code null}, wenn keine Feldgruppe mit der gegebenen ID gefunden werden konnte
   * oder die Feldgruppe keine Instanz mit dem gegebenen Index hat
   * @throws NullPointerException Falls die gegebene ID {@code null} ist
   */
  public FieldGroupInstanceV1 getGroupInstance(String id, int index) {
    FieldGroupV1 group = getGroupTemplate(id);
    return group == null ? null : group.getGroupInstance(index);
  }

  /**
   * Gibt die Liste aller Feldgruppen-Instanzen zurück.
   *
   * @return Liste aller Feldgruppen-Instanzen
   * @see #getGroupInstancesWith
   */
  public List<FieldGroupInstanceV1> getGroupInstances() {
    return getGroupInstancesWith(g -> Boolean.TRUE);
  }

  /**
   * Gibt die Liste aller Feldgruppen-Instanzen, die das gegebene Predicate erfüllen, zurück.
   *
   * @param predicate Boolesche Funktion zum Filtern der Feldgruppeninstanzen, nicht {@code null}
   *
   * @return Liste der Feldgruppen-Instanzen die das Predicate erfüllen
   * @throws NullPointerException Wenn das gegebene Predicate {@code null} ist
   */
  public List<FieldGroupInstanceV1> getGroupInstancesWith(Predicate<FieldGroupInstanceV1> predicate) {
    return sections.stream().flatMap(s -> s.getFieldGroups().stream()).flatMap(g -> g.getInstances().stream()).filter(predicate).collect(Collectors.toList());
  }

  /**
   * Gibt das Feld für den gegebenen FormFieldKey zurück.
   *
   * @param key FormFieldKey zum referenzieren auf ein Feld, nicht {@code null}
   *
   * @return Feld für den gegebene FormFieldKey oder {@code null} wenn das gegebene Feld nicht existiert
   * @throws NullPointerException Falls der gegebene FormFieldKey {@code null} ist
   */
  public FormFieldV1 getFieldInInstance(FormFieldKeyV1 key) {
    FieldGroupV1 group = getGroupTemplate(key.getGroupId());
    return group == null ? null : group.getFieldInInstance(key.getGroupIndex(), key.getFieldId());
  }

  /**
   * Gibt alle Felder mit dem gegebenen Typ aus allen Feldgruppen-Instanzen zurück.
   *
   * @param type Feldtyp, nicht {@code null}
   *
   * @return Liste der Felder mit dem gegebene Typ
   * @throws NullPointerException Falls der gegebene Typ {@code null} ist
   */
  public List<FormFieldV1> getInstanceFieldsWith(FieldTypeV1 type) {
    return getInstanceFieldsWith(f -> type == f.getType());
  }

  /**
   * Gibt alle Felder, die das gegebene Predicate erfüllen, aus allen Feldgruppen-Instanzen zurück.
   *
   * @param predicate Boolesche Funktion zum Filtern von Feldern, nicht {@code null}
   *
   * @return Liste der Felder aus den Feldgruppen-Instanzen, die das gegebene Predicate erfüllen
   * @throws NullPointerException Falls das gegebene Predicate {@code null} ist
   */
  public List<FormFieldV1> getInstanceFieldsWith(Predicate<FormFieldV1> predicate) {
    return sections.stream().flatMap(section -> section.getFieldGroups().stream()).flatMap(group -> group.getFieldsInInstanceWith(predicate).stream()).collect(Collectors.toList());
  }

  /**
   * Gibt die Liste der Validierungsmeldungen am Formular zurück. Der Typ der Validierungsmeldungen wird
   * ignoriert.
   *
   * @return Liste der Validierungsmeldungen am Formular
   */
  public List<String> getValidationMessagesAsString() {
    return validationMessages.stream().map(ValidationMessageV1::getMessageText).collect(Collectors.toList());
  }

  /**
   * Der gegebene String wird als Validierungsmeldung vom Typ {@link MessageTypeV1#INTERNAL INTERNAL}
   * zu den Validierungsmeldungen des Formulars hinzugefügt.
   *
   * @param message Validierungsmeldung, die hinzugefügt wird
   */
  public void addValidationMessage(String message) {
    validationMessages.add(new ValidationMessageV1(MessageTypeV1.INTERNAL, message));
  }

  /**
   * Gibt den Inhalt dieses Formulars zurück,
   *
   * @return FormContent mit den Inhalten des Formulars
   */
  public FormContentV1 getContent() {
    return FormContentV1.builder().appliedReplacements(appliedReplacements).formId(id).formTitle(title).validationMessages(new ArrayList<>(validationMessages)).createdOn(new Date()).context(getContextForContent()).fields(getFieldsForContent()).pressedCustomButton(getPressedCustomButtonForContent()).build();
  }

  private Map<String, Object> getContextForContent() {
    return context == null ? null : new HashMap<>(context);
  }

  private Map<String, FormFieldContentV1> getFieldsForContent() {
    Map<String, FormFieldContentV1> fields = new HashMap<>();
    boolean traverseSuccessful = traverseFormConsideringDisplayConditions((f, g) -> addField(fields, g, f));
    if (!traverseSuccessful) {
      for (FieldGroupInstanceV1 group : getGroupInstances()) {
        for (FormFieldV1 field : group.getFieldsWith(b -> Boolean.TRUE)) {
          addField(fields, group, field);
        }
      }
    }
    return fields;
  }

  private boolean traverseFormConsideringDisplayConditions(BiConsumer<FormFieldV1, FieldGroupInstanceV1> handleVisibleFormField) {
    Set<FormFieldKeyV1> processedFields = new HashSet<>();
    final int MAX_COUNT = 100;
    int count = 0;
    boolean pendingDisplayConditions;
    do {
      pendingDisplayConditions = false;
      for (FieldGroupInstanceV1 groupInstance : getGroupInstances()) {
        pendingDisplayConditions |= !traverseFieldGroupConsideringDisplayConditions(groupInstance, handleVisibleFormField, processedFields);
      }
      count++;
    } while (pendingDisplayConditions && count < MAX_COUNT);
    return count < MAX_COUNT;
  }

  private boolean traverseFieldGroupConsideringDisplayConditions(FieldGroupInstanceV1 instance, BiConsumer<FormFieldV1, FieldGroupInstanceV1> handleVisibleFormField, Set<FormFieldKeyV1> processedFields) {
    if (!processedFields.containsAll(instance.fieldsReferencedInDisplayConditions())) {
      return false;
    }
    if (!instance.isShown(this)) {
      instance.getFieldsWith(b -> Boolean.TRUE).forEach(f -> processedFields.add(new FormFieldKeyV1(instance, f)));
      return true;
    }
    boolean pendingDisplayConditions = false;
    for (FormFieldV1 field : instance.getFieldsWith(b -> Boolean.TRUE)) {
      if (!processedFields.containsAll(field.fieldsReferencedInDisplayConditions(instance))) {
        pendingDisplayConditions = true;
        continue;
      }
      processedFields.add(new FormFieldKeyV1(instance, field));
      if (!field.isShown(instance, this)) {
        continue;
      }
      handleVisibleFormField.accept(field, instance);
    }
    return !pendingDisplayConditions;
  }

  private void addField(Map<String, FormFieldContentV1> formContent, FieldGroupInstanceV1 group, FormFieldV1 field) {
    String key = new FormFieldKeyV1(group, field).toString();
    FormFieldContentV1 content = FormFieldContentV1.builder().value(field.getValue()).validationMessages(new ArrayList<>(field.getValidationMessages())).possibleValues(field.getPossibleValues()).build();
    formContent.put(key, content);
  }

  private String getPressedCustomButtonForContent() {
    if (customButtons == null) {
      return null;
    }
    return customButtons.getButtons().stream().filter(CustomButtonV1::isWasPressed).findFirst().map(CustomButtonV1::getValue).orElse(null);
  }

  /**
   * Befüllt dieses Formular mit dem gegebenen Inhalt.
   * <p>
   * Die Struktur des Formulars ändert sich durch diese Methode nicht. Werte die sich auf Gruppen oder Felder
   * beziehen, die in diesem Formular nicht existieren, werden nicht übertragen. Höchstens fehlende
   * Feldgruppen-Instanzen werden hinzugefügt.
   * <br>
   * Beim Übertragen der Feldwerte wird keine Typprüfung durchgeführt - es wird nicht geprüft, dass der Wert
   * im FormContent zum Typ des Feldes passt.
   *
   * @param content Formularinhalte, nicht {@code null}
   *
   * @throws NullPointerException Falls der gegebene Formularinhalt {@code null} ist
   */
  public void setContent(FormContentV1 content) {
    this.validationMessages = new HashSet<>(content.getValidationMessages());
    if (content.getContext() != null) {
      this.context = new HashMap<>(content.getContext());
    }
    if (customButtons != null) {
      for (CustomButtonV1 customButton : customButtons.getButtons()) {
        boolean tmp = content.getPressedCustomButton() != null && content.getPressedCustomButton().equals(customButton.getValue());
        customButton.setWasPressed(tmp);
      }
    }
    content.getFields().entrySet().forEach(this::setFieldContent);
  }

  private void setFieldContent(Map.Entry<String, FormFieldContentV1> entry) {
    FormFieldKeyV1 key = new FormFieldKeyV1(entry.getKey());
    FormFieldV1 field = getFieldInInstanceOrCreateInstanceIfPossible(key);
    if (field == null) {
      return;
    }
    FormFieldContentV1 content = entry.getValue();
    field.setValue(content.getValue());
    field.setValidationMessages(new HashSet<>(content.getValidationMessages()));
    if (content.getPossibleValues() != null) {
      field.setPossibleValues(content.getPossibleValues());
    }
  }

  private FormFieldV1 getFieldInInstanceOrCreateInstanceIfPossible(FormFieldKeyV1 key) {
    FieldGroupV1 group = getGroupTemplate(key.getGroupId());
    if (group == null) {
      return null;
    }
    FieldGroupInstanceV1 instance = group.getGroupInstanceOrCreateIfPossible(key.getGroupIndex());
    if (instance == null) {
      return null;
    }
    return instance.getField(key.getFieldId());
  }

  @SuppressWarnings("all")
  private static List<FormSectionV1> $default$sections() {
    return new ArrayList<>();
  }

  @SuppressWarnings("all")
  private static Set<ValidationMessageV1> $default$validationMessages() {
    return new HashSet<>();
  }


  @SuppressWarnings("all")
  public static class FormV1Builder {
    @SuppressWarnings("all")
    private String id;
    @SuppressWarnings("all")
    private String title;
    @SuppressWarnings("all")
    private String language;
    @SuppressWarnings("all")
    private boolean sections$set;
    @SuppressWarnings("all")
    private List<FormSectionV1> sections$value;
    @SuppressWarnings("all")
    private DataResourcePointerV1 source;
    @SuppressWarnings("all")
    private DataResourcePointerV1 target;
    @SuppressWarnings("all")
    private boolean validationMessages$set;
    @SuppressWarnings("all")
    private Set<ValidationMessageV1> validationMessages$value;
    @SuppressWarnings("all")
    private Map<String, Object> context;
    @SuppressWarnings("all")
    private CustomButtonsV1 customButtons;
    @SuppressWarnings("all")
    private FormReplacementValuesV1 appliedReplacements;

    @SuppressWarnings("all")
    FormV1Builder() {
    }

    /**
     * ID des Formulars.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder id(@NonNull final String id) {
      if (id == null) {
        throw new NullPointerException("id is marked non-null but is null");
      }
      this.id = id;
      return this;
    }

    /**
     * Titel dieses Formulars.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder title(final String title) {
      this.title = title;
      return this;
    }

    /**
     * Sprache dieses Formulars.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder language(final String language) {
      this.language = language;
      return this;
    }

    /**
     * Liste der Formularabschnitte. Default ist eine leere Liste.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder sections(@NonNull final List<FormSectionV1> sections) {
      if (sections == null) {
        throw new NullPointerException("sections is marked non-null but is null");
      }
      this.sections$value = sections;
      sections$set = true;
      return this;
    }

    /**
     * Quelle, aus der die Inhalte des gesamten Formulars gelesen werden.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder source(final DataResourcePointerV1 source) {
      this.source = source;
      return this;
    }

    /**
     * Ziel, in das der Inhalt des gesamten Formulars geschrieben werden.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder target(final DataResourcePointerV1 target) {
      this.target = target;
      return this;
    }

    /**
     * Validierungsmeldungen des gesamten Formulars. Default ist leere Menge.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder validationMessages(@NonNull final Set<ValidationMessageV1> validationMessages) {
      if (validationMessages == null) {
        throw new NullPointerException("validationMessages is marked non-null but is null");
      }
      this.validationMessages$value = validationMessages;
      validationMessages$set = true;
      return this;
    }

    /**
     * Kontext, in dem das Formular abgeschickt wurde.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder context(final Map<String, Object> context) {
      this.context = context;
      return this;
    }

    /**
     * Enthält die Custom-Buttons.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder customButtons(final CustomButtonsV1 customButtons) {
      this.customButtons = customButtons;
      return this;
    }

    /**
     * Die Ersetzungswerte für Platzhalter in der Formulardefinition, die verwendet wurden, um die
     * Formulardefinition zu vervollständigen. Dient dazu, um aus der Formulardefinition mit Platzhaltern wieder
     * eine vollständige Formulardefinition machen zu können.
     * @return {@code this}.
     */
    @SuppressWarnings("all")
    public FormV1.FormV1Builder appliedReplacements(final FormReplacementValuesV1 appliedReplacements) {
      this.appliedReplacements = appliedReplacements;
      return this;
    }

    @SuppressWarnings("all")
    public FormV1 build() {
      List<FormSectionV1> sections$value = this.sections$value;
      if (!this.sections$set) sections$value = FormV1.$default$sections();
      Set<ValidationMessageV1> validationMessages$value = this.validationMessages$value;
      if (!this.validationMessages$set) validationMessages$value = FormV1.$default$validationMessages();
      return new FormV1(this.id, this.title, this.language, sections$value, this.source, this.target, validationMessages$value, this.context, this.customButtons, this.appliedReplacements);
    }

    @Override
    @SuppressWarnings("all")
    public String toString() {
      return "FormV1.FormV1Builder(id=" + this.id + ", title=" + this.title + ", language=" + this.language + ", sections$value=" + this.sections$value + ", source=" + this.source + ", target=" + this.target + ", validationMessages$value=" + this.validationMessages$value + ", context=" + this.context + ", customButtons=" + this.customButtons + ", appliedReplacements=" + this.appliedReplacements + ")";
    }
  }

  @SuppressWarnings("all")
  public static FormV1.FormV1Builder builder() {
    return new FormV1.FormV1Builder();
  }

  /**
   * ID des Formulars.
   */
  @NonNull
  @SuppressWarnings("all")
  public String getId() {
    return this.id;
  }

  /**
   * Titel dieses Formulars.
   */
  @SuppressWarnings("all")
  public String getTitle() {
    return this.title;
  }

  /**
   * Sprache dieses Formulars.
   */
  @SuppressWarnings("all")
  public String getLanguage() {
    return this.language;
  }

  /**
   * Liste der Formularabschnitte. Default ist eine leere Liste.
   */
  @NonNull
  @SuppressWarnings("all")
  public List<FormSectionV1> getSections() {
    return this.sections;
  }

  /**
   * Quelle, aus der die Inhalte des gesamten Formulars gelesen werden.
   */
  @SuppressWarnings("all")
  public DataResourcePointerV1 getSource() {
    return this.source;
  }

  /**
   * Ziel, in das der Inhalt des gesamten Formulars geschrieben werden.
   */
  @SuppressWarnings("all")
  public DataResourcePointerV1 getTarget() {
    return this.target;
  }

  /**
   * Validierungsmeldungen des gesamten Formulars. Default ist leere Menge.
   */
  @NonNull
  @SuppressWarnings("all")
  public Set<ValidationMessageV1> getValidationMessages() {
    return this.validationMessages;
  }

  /**
   * Kontext, in dem das Formular abgeschickt wurde.
   */
  @SuppressWarnings("all")
  public Map<String, Object> getContext() {
    return this.context;
  }

  /**
   * Enthält die Custom-Buttons.
   */
  @SuppressWarnings("all")
  public CustomButtonsV1 getCustomButtons() {
    return this.customButtons;
  }

  /**
   * Die Ersetzungswerte für Platzhalter in der Formulardefinition, die verwendet wurden, um die
   * Formulardefinition zu vervollständigen. Dient dazu, um aus der Formulardefinition mit Platzhaltern wieder
   * eine vollständige Formulardefinition machen zu können.
   */
  @SuppressWarnings("all")
  public FormReplacementValuesV1 getAppliedReplacements() {
    return this.appliedReplacements;
  }

  /**
   * ID des Formulars.
   */
  @SuppressWarnings("all")
  public void setId(@NonNull final String id) {
    if (id == null) {
      throw new NullPointerException("id is marked non-null but is null");
    }
    this.id = id;
  }

  /**
   * Titel dieses Formulars.
   */
  @SuppressWarnings("all")
  public void setTitle(final String title) {
    this.title = title;
  }

  /**
   * Sprache dieses Formulars.
   */
  @SuppressWarnings("all")
  public void setLanguage(final String language) {
    this.language = language;
  }

  /**
   * Liste der Formularabschnitte. Default ist eine leere Liste.
   */
  @SuppressWarnings("all")
  public void setSections(@NonNull final List<FormSectionV1> sections) {
    if (sections == null) {
      throw new NullPointerException("sections is marked non-null but is null");
    }
    this.sections = sections;
  }

  /**
   * Quelle, aus der die Inhalte des gesamten Formulars gelesen werden.
   */
  @SuppressWarnings("all")
  public void setSource(final DataResourcePointerV1 source) {
    this.source = source;
  }

  /**
   * Ziel, in das der Inhalt des gesamten Formulars geschrieben werden.
   */
  @SuppressWarnings("all")
  public void setTarget(final DataResourcePointerV1 target) {
    this.target = target;
  }

  /**
   * Validierungsmeldungen des gesamten Formulars. Default ist leere Menge.
   */
  @SuppressWarnings("all")
  public void setValidationMessages(@NonNull final Set<ValidationMessageV1> validationMessages) {
    if (validationMessages == null) {
      throw new NullPointerException("validationMessages is marked non-null but is null");
    }
    this.validationMessages = validationMessages;
  }

  /**
   * Kontext, in dem das Formular abgeschickt wurde.
   */
  @SuppressWarnings("all")
  public void setContext(final Map<String, Object> context) {
    this.context = context;
  }

  /**
   * Enthält die Custom-Buttons.
   */
  @SuppressWarnings("all")
  public void setCustomButtons(final CustomButtonsV1 customButtons) {
    this.customButtons = customButtons;
  }

  /**
   * Die Ersetzungswerte für Platzhalter in der Formulardefinition, die verwendet wurden, um die
   * Formulardefinition zu vervollständigen. Dient dazu, um aus der Formulardefinition mit Platzhaltern wieder
   * eine vollständige Formulardefinition machen zu können.
   */
  @SuppressWarnings("all")
  public void setAppliedReplacements(final FormReplacementValuesV1 appliedReplacements) {
    this.appliedReplacements = appliedReplacements;
  }

  @Override
  @SuppressWarnings("all")
  public boolean equals(final Object o) {
    if (o == this) return true;
    if (!(o instanceof FormV1)) return false;
    final FormV1 other = (FormV1) o;
    if (!other.canEqual((Object) this)) return false;
    final Object this$id = this.getId();
    final Object other$id = other.getId();
    if (this$id == null ? other$id != null : !this$id.equals(other$id)) return false;
    final Object this$title = this.getTitle();
    final Object other$title = other.getTitle();
    if (this$title == null ? other$title != null : !this$title.equals(other$title)) return false;
    final Object this$language = this.getLanguage();
    final Object other$language = other.getLanguage();
    if (this$language == null ? other$language != null : !this$language.equals(other$language)) return false;
    final Object this$sections = this.getSections();
    final Object other$sections = other.getSections();
    if (this$sections == null ? other$sections != null : !this$sections.equals(other$sections)) return false;
    final Object this$source = this.getSource();
    final Object other$source = other.getSource();
    if (this$source == null ? other$source != null : !this$source.equals(other$source)) return false;
    final Object this$target = this.getTarget();
    final Object other$target = other.getTarget();
    if (this$target == null ? other$target != null : !this$target.equals(other$target)) return false;
    final Object this$validationMessages = this.getValidationMessages();
    final Object other$validationMessages = other.getValidationMessages();
    if (this$validationMessages == null ? other$validationMessages != null : !this$validationMessages.equals(other$validationMessages)) return false;
    final Object this$context = this.getContext();
    final Object other$context = other.getContext();
    if (this$context == null ? other$context != null : !this$context.equals(other$context)) return false;
    final Object this$customButtons = this.getCustomButtons();
    final Object other$customButtons = other.getCustomButtons();
    if (this$customButtons == null ? other$customButtons != null : !this$customButtons.equals(other$customButtons)) return false;
    final Object this$appliedReplacements = this.getAppliedReplacements();
    final Object other$appliedReplacements = other.getAppliedReplacements();
    if (this$appliedReplacements == null ? other$appliedReplacements != null : !this$appliedReplacements.equals(other$appliedReplacements)) return false;
    return true;
  }

  @SuppressWarnings("all")
  protected boolean canEqual(final Object other) {
    return other instanceof FormV1;
  }

  @Override
  @SuppressWarnings("all")
  public int hashCode() {
    final int PRIME = 59;
    int result = 1;
    final Object $id = this.getId();
    result = result * PRIME + ($id == null ? 43 : $id.hashCode());
    final Object $title = this.getTitle();
    result = result * PRIME + ($title == null ? 43 : $title.hashCode());
    final Object $language = this.getLanguage();
    result = result * PRIME + ($language == null ? 43 : $language.hashCode());
    final Object $sections = this.getSections();
    result = result * PRIME + ($sections == null ? 43 : $sections.hashCode());
    final Object $source = this.getSource();
    result = result * PRIME + ($source == null ? 43 : $source.hashCode());
    final Object $target = this.getTarget();
    result = result * PRIME + ($target == null ? 43 : $target.hashCode());
    final Object $validationMessages = this.getValidationMessages();
    result = result * PRIME + ($validationMessages == null ? 43 : $validationMessages.hashCode());
    final Object $context = this.getContext();
    result = result * PRIME + ($context == null ? 43 : $context.hashCode());
    final Object $customButtons = this.getCustomButtons();
    result = result * PRIME + ($customButtons == null ? 43 : $customButtons.hashCode());
    final Object $appliedReplacements = this.getAppliedReplacements();
    result = result * PRIME + ($appliedReplacements == null ? 43 : $appliedReplacements.hashCode());
    return result;
  }

  @Override
  @SuppressWarnings("all")
  public String toString() {
    return "FormV1(id=" + this.getId() + ", title=" + this.getTitle() + ", language=" + this.getLanguage() + ", sections=" + this.getSections() + ", source=" + this.getSource() + ", target=" + this.getTarget() + ", validationMessages=" + this.getValidationMessages() + ", context=" + this.getContext() + ", customButtons=" + this.getCustomButtons() + ", appliedReplacements=" + this.getAppliedReplacements() + ")";
  }

  @SuppressWarnings("all")
  private FormV1(@NonNull final String id, final String title, final String language, @NonNull final List<FormSectionV1> sections, final DataResourcePointerV1 source, final DataResourcePointerV1 target, @NonNull final Set<ValidationMessageV1> validationMessages, final Map<String, Object> context, final CustomButtonsV1 customButtons, final FormReplacementValuesV1 appliedReplacements) {
    if (id == null) {
      throw new NullPointerException("id is marked non-null but is null");
    }
    if (sections == null) {
      throw new NullPointerException("sections is marked non-null but is null");
    }
    if (validationMessages == null) {
      throw new NullPointerException("validationMessages is marked non-null but is null");
    }
    this.id = id;
    this.title = title;
    this.language = language;
    this.sections = sections;
    this.source = source;
    this.target = target;
    this.validationMessages = validationMessages;
    this.context = context;
    this.customButtons = customButtons;
    this.appliedReplacements = appliedReplacements;
  }
}
